class Solution {
private:
    void dfs(int node,vector<bool>& visited,vector<int>& comp,vector<vector<int>>& adj){
        visited[node]= true;
        comp.push_back(node);
        for(auto neigh:adj[node]){
            if(!visited[neigh]){
                dfs(neigh,visited,comp,adj);
            }
        }
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int m = graph[0].size();
        vector<vector<int>> adj(n);
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(i!=j && graph[i][j]==1){
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }

        vector<bool> visited(n,false);
        
        vector<vector<int>> final;
        for(int i=0;i<n;i++){
            if(!visited[i]){
                vector<int> comp;
                dfs(i,visited,comp,adj);
                final.push_back(comp);
            }
        }

        vector<bool> infected(n,false);
        for(int i:initial){
            infected[i]=true;
        }
         int ans1 = 1e8 , ans = 1e7;
         int sz = 0;
        for(auto i:final){
            int cn = 0 ,ind = 1e9;
            for(auto j:i){
                if(infected[j]){
                    cn++;
                    ind = min(ind,j);
                }
            }
            if(cn==1){
                if(i.size()>sz){
                    ans1 = ind;
                    sz = i.size();
                }
                else if(i.size()==sz)
                ans1 = min(ans1,ind);
                else continue;
            }
            else{
                ans = min(ans,ind);
            }
        }
       
        return (ans1!=1e8)?ans1:ans;

    }
};